I"#<p>이득우의 언리얼 C++ 게임 개발의 정석의 Chapter09 요약입니다.</p>

<h3 id="콜리전-설정">콜리전 설정</h3>
<ul>
  <li>언리얼 엔진에서 콜리전은 크게 세가지 방법으로 제작할 수 있다.
    <ul>
      <li>스태틱메시 에셋 : 스태틱메시 애셋에 콜리전 영역을 심는 방법이다. 스테틱 메시 애셋에 콜리전을 심으면 스태택메시 컴포넌트에서 비주얼과 충돌이라는 두가지 기능을 설정할 수 있다.</li>
      <li>기본 도형 컴포넌트 : 구체, 박스, 캡슐의 기본 도형을 사용해 충돌 영역을 지정하는 방법이다. 스태틱 메시와 별도로 충돌 영역을 제작하는데 사용된다. 스켈레탈 메시를 움직일 때 주로 사용한다.</li>
      <li>피직스 에셋 : 일반적으로 캐릭터의 이동은 캡슐 컴포넌트를 사용해 처리한다. 하지만 특정 상황에서 캐릭터의 각 관절이 흐느적거리는 헝겊 인형(Rag Doll)효과를 구현할 때 이 피직스 애셋을 사용한다. 캐릭터의 각 부위에 기본 도형으로 충돌 영역을 설정하고 이를 연결해 캐릭터의 물리를 설정한다. 피직스 애셋은 스켈레탈 메시에만 사용할 수 있다.</li>
    </ul>
  </li>
  <li>물리 설정은 크게 다음 세가지로 구분된다.
    <ul>
      <li>콜리전 채널과 기본 반응</li>
      <li>콜리전 채널의 용도</li>
      <li>다른 콜리전 채널과의 반응</li>
    </ul>
  </li>
  <li>충돌체에는 반드시 하나의 콜리전 채널을 설정해야 한다. 언리얼 엔진은 총 8개의 기본 콜리전 채널을 제공한다.
    <ul>
      <li>WorldStatic : 움직이지 않는 정적인 배경 액터에 사용하는 콜리전 채널이다. 주로 스태틱메시 액터에 있는 스태틱 메시 컴포넌트에 사용한다.</li>
      <li>WorldDynamic : 움직이는 액터에 사용하는 콜리전 채널이다. 블루프린트에 속한 스태틱 메시 컴포넌트에 사용한다.</li>
      <li>Pawn : 플레이어가 조종하는 물체에 주로 사용한다. 캐릭터의 충돌을 담당하는 캡슐 컴포넌트에 설정된다.</li>
      <li>Visibility : 배경 물체가 시작적으로 보이는지 탐지하는데 사용한다. 탐지에서 폰은 제외된다. 마우스로 물체를 선택하는 피킹(picking)기능을 구현할 때 사용한다.</li>
      <li>Camera : 카메라 설정을 위해 카메라와 목표물 간에 장애물이 있는지 탐지하는데 사용한다. 이전 GTA 방식으로 캐릭터를 조작할 때 장애물이 시야를 가리면 카메라를 장애물 앞으로 줌인하는 기능이 있었다. 이 때 사용하는 채널이 Camera 채널이다.</li>
      <li>PhysicsBody : 물리 시뮬레이션으로 움직이는 컴포넌트에 설정한다.</li>
    </ul>
  </li>
  <li>콜리전 프리셋 값 Pawn과 ObjectType의 값 Pawn은 서로 다른 설정 값이니 혼동하지 않도록 주의한다.</li>
  <li>컴포넌트에서 물리 기능을 어떻게 사용할지 지정해야 하는데 ObjectType 위에 위치한 Collision Enabled 항목을 설정하면 된다.
    <ul>
      <li>Query : 두 물체의 충돌 영역이 서로 켭치는지 테스트하는 설정이다. 충돌 영역의 겹침을 감지하는 것은 언리얼 엔진에서 오버랩(Overlap)이라 부르며, 충돌 영역이 겹치면 관련 컴포넌트에 BeginOverlap 이벤트가 발생한다. 지정한 영역에 물체가 충돌하는지 탐지하는 레이케스트(Raycast)나 스윕(Sweep) 기능도 Query에 속한다.</li>
      <li>Physics : 물리적인 시뮬레이션을 사용할 때 설정한다.</li>
      <li>Query and Physics : 위의 기능을 모두 사용하는 설정이다.</li>
    </ul>
  </li>
  <li>Query and Physics로 설정을 사용하면 모든 기능이 잘 동작하겠지만, 물리 엔진이 수행하는 계산량이 많아진다. 따라서 액터마다 자신에게 필요한 기능을 파악해 Query나 Physics 설정만 지정하는 것이 효과적이라고 할 수 있다.</li>
  <li>다른 콜리전 채널과의 반응에 무시, 겹침, 블록이라는 세가지 기능을 사용할 수 있다.
    <ul>
      <li>무시(Ignore) : 콜리전이 있어도 아무 충돌이 일어나지 않는다.</li>
      <li>겹침(Overlap) : 무시와 동일하게 물체가 뚫고 지나갈 수 있지만 이벤트를 발생시킨다.</li>
      <li>블록(Block) : 물체가 뚫고 지나가지 못하도록 막는다.</li>
    </ul>
  </li>
  <li>콜리전 채널은 오브젝트 채널과 트레이스 채널로 나뉜다.
    <ul>
      <li>오브젝트 채널 : 콜리전 영역에 지정하는 콜리전 채널</li>
      <li>트레이스 채널 : 어떤 행동에 설정하는 콜리전 채널</li>
    </ul>
  </li>
  <li>신경 써야될 프리셋들
    <ul>
      <li>OverlapAll : 겹침으로 설정</li>
      <li>OverlapAllDynamic : 겹침으로 설정한다.</li>
      <li>IgnoreOnlyPawn : 폰만 충돌을 무시하도록 설정한다. 무시로 설정</li>
      <li>OverlapOnlyPawn : 폰만 겹침 이벤트가 발생하도록 설정한다. 겹침으로 설정한다.</li>
      <li>Spectator : 외부 관중과 충돌을 설정한다. 무시로 설정한다.</li>
      <li>CharacterMesh : 캐릭터 메시에 사용하는 물리 설정이다. 무시로 설정한다.</li>
      <li>RagDoll : 스켈레탈 메시의 피직스 애셋 물리를 가동하기 위한 물리 설정이다. 무시로 설정한다.</li>
      <li>Trigger : 지정한 영역에 물체가 들어오면 이벤트가 발동하는 용도로 사용한다. 겹침으로 설정한다.</li>
      <li>UI : UI요소에 사용하는 설정이다. 겹침으로 설정한다.</li>
    </ul>
  </li>
</ul>

<h3 id="트레이스-채널의-활용">트레이스 채널의 활용</h3>
<ul>
  <li>트레이스 채널을 사용해 물리적 충돌 여부를 가리는 함수 중 하나로 SweepSingleByChannel이 있다.
    <ul>
      <li>물리는 월드의 기능이므로 GetWorld() 함수를 사용해 월드에게 명령을 내린다.</li>
      <li>해당 함수는 기본 도형을 인자로 받은 후 시작 지점에서 끝까지 쓸면서(Sweep) 해당 영역 내에 물리 판정이 일어났는지를 조사한다.</li>
      <li>파라매타 설정들
        <ul>
          <li>HitResult : 물리적 충돌이 탐지된 경우 관련된 정보를 담은 구조체</li>
          <li>Start : 탐색을 시작할 위치</li>
          <li>End : 탐색을 끝낼 위치</li>
          <li>Rot : 탐색에 사용할 도형의 회전</li>
          <li>TraceChannel : 물리 충돌 감지에 사용할 트레이스 정보</li>
          <li>CollisionShape : 탐색에 사용할 기본 도형 정보, 구체, 캡슐, 박스를 사용한다.</li>
          <li>Params : 탐색 방법에 대한 설정 값을 모아둔 구조체</li>
          <li>ResponseParams : 탐색 반응을 설정하기 위한 구조체</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>언리얼 엔진은 게임에서 활용할 수 있도록 총 32개의 콜리전 채널을 제공한다. 32개 중 8개는 언리얼 엔진이 기본으로 사용하고, 여섯 개는 엔진에서 다른 용도로 사용하도록 예약되어 있다. 우리가 만드는 게임 프로젝트에서는 이를 뺀 나머지 18개만 사용할 수 있다.</li>
</ul>

<h3 id="디버그-드로잉">디버그 드로잉</h3>
<ul>
  <li>공격할 때마다 로그 창을 열고 이를 매번 탐지하는 것은 번거로운 작업이다. 공격 범위가 시각적으로 보이지 않다 보니, 어떻게 맞았는지 어떻게 미스가 났는지 파악할 수 없는 문제도 있다. 이럴 때 언리얼 엔진에서 제공하는 디버그 드로잉(Debug Drawing) 기능을 사용하면 이 문제를 해결 할 수 있다.</li>
  <li>디버깅 드로잉 기능을 사용하기 위해 소스 상단에 DebugDrawHelpers.h 헤더를 추가해야 한다. (4.25 버전에서는 기본 도형에 대한 헤더가 추가되어 있다.)</li>
</ul>

<h3 id="데미지-프레임워크">데미지 프레임워크</h3>
<ul>
  <li>언리얼 엔진의 액터 클래스 AActor는 TakeDamage라는 함수가 구현되어 있다. 이 함수를 사용하면 손쉽게 액터에 데미지를 전달할 수 있다. 이 함수는 총 4가지 인자를 가지고 있다.
    <ul>
      <li>DamageAmount : 전달할 데미지의 세기</li>
      <li>DamageEvent : 데미지의 종류</li>
      <li>EventInstigator : 공력 명령을 내린 가해자</li>
      <li>DamageCauser : 데미지 전달을 위해 사용한 도구</li>
    </ul>
  </li>
  <li>데미지를 가한 진정한 가해자는 폰이 아니라 명령을 내린 플레이어 컨트롤러이기 때문에 EventInstigator에는 컨트롤러의 정보를 보내줘야 한다.</li>
  <li>모든 액터 설정에는 Can be Damaged 속성이 있으므로, 이 속성의 체크를 해제하면 캐릭터에 전달되는 데미지가 모두 0이 되어 무적 상태가 된다.</li>
</ul>
:ET