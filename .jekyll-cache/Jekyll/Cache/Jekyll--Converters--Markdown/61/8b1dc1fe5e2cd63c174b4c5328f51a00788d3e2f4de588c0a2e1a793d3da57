I"î6<h1 id="outcast">Outcast</h1>

<p>OutcastëŠ” SF ì ì…ì•¡ì…˜ ì»¨ì…‰ì˜ VR ê²Œì„ ì½˜í…ì¸ ì…ë‹ˆë‹¤.
ì¡ì… ì•¡ì…˜ì„ ì¢€ ë” ì‹¤ê°ë‚˜ê²Œ êµ¬í˜„í•˜ê¸° ìœ„í•´ ì´ë™ë°©ì‹ê³¼ ë²½íƒ€ê¸°, ì  ì‹œì•¼íƒì§€ ë“±ì„ ê°œë°œí–ˆê³ , ì¶”ê°€ë¡œ ì—¬ëŸ¬ ì¬ë¯¸ìš”ì†Œë¡œ ì¥ì „ ë°©ì‹ì´ë‚˜ ë„íƒ„, ë“œë¡  ë“±ì„ ì¶”ê°€í–ˆìŠµë‹ˆë‹¤.</p>

<h3 id="ìŠ¤í¬ë¦°-ìƒ·">ìŠ¤í¬ë¦° ìƒ·</h3>

<p><img src="https://user-images.githubusercontent.com/49055264/86313672-ac310f00-bc60-11ea-9e07-789b5975c656.png" style="float: left;  margin-right: 20px; margin-bottom: 10px" width="450px" height="300px" /><br /></p>

<p><img src="https://user-images.githubusercontent.com/49055264/86313678-adfad280-bc60-11ea-90b0-28f9708556f0.png" style="float: left;  margin-right: 20px; margin-bottom: 10px" width="450px" height="300px" /><br /></p>

<p><img src="https://user-images.githubusercontent.com/49055264/86313681-ae936900-bc60-11ea-97e7-19d25e62b6e5.png" style="float: left;  margin-right: 20px; margin-bottom: 10px" width="450px" height="300px" /><br /></p>

<p><img src="https://user-images.githubusercontent.com/49055264/86313682-ae936900-bc60-11ea-99f4-85e0265b94ee.png" style="float: left;  margin-right: 20px; margin-bottom: 10px" width="450px" height="300px" /><br /></p>

<p><img src="https://user-images.githubusercontent.com/49055264/86313687-af2bff80-bc60-11ea-8663-1389a35047b7.png" style="margin-right: 20px; margin-bottom: 10px" width="450px" height="300px" /><br /></p>

<h3 id="ê°œìš”">ê°œìš”</h3>
<ul>
  <li>ì˜ìƒ ë§í¬ : https://www.youtube.com/watch?v=xBQvsTsA6IA&amp;feature=youtu.be&amp;t=0s</li>
  <li>Github Link : https://github.com/HyoungHoKim/Outcast_OnlyScript (í”„ë¡œì íŠ¸ì— ì—¬ëŸ¬ ìœ ë£Œ ì—ì…‹ì„ ì‚¬ìš©í–ˆê¸° ë•Œë¬¸ì—, ì €ì‘ê¶Œ ë¬¸ì œë¡œ ì§ì ‘ ì§  ì½”ë“œë§Œì„ ê³µê°œ)</li>
  <li>ë©”ë””ì¹˜ ì–´íŠ¸ë™ì…˜ ê¸°ë°˜ VR ê°œë°œì ì–‘ì„± ê³¼ì • ìµœì¢… í”„ë¡œì íŠ¸</li>
  <li>ê°œë°œ ê¸°ê°„ : 2020.04.28 ~ 2020.06.10</li>
  <li>ì¥ë¹„ : Vive Pro, Vive Tracker, KATVR mini</li>
  <li>íŒ€ëª… : ê°€ì‚° ë©”ë””ì¹˜ ì—°í•©</li>
  <li>íŒ€ì› : ì´ê²½í•˜(íŒ€ì¥, ì—ë„ˆë¯¸, ë¹„ì£¼ì–¼ ì´í™íŠ¸, ì–´íŠ¸ë™ì…˜), ê¹€í˜•í˜¸(í”Œë ˆì´ì–´, í”Œë ˆì´ì–´ IK, íŠ¹ìˆ˜ ìƒí˜¸ì‘ìš©), ë°•ì² ìš°(ë“œë¡  AI, UI, ë ˆë²¨ ë””ìì¸)</li>
</ul>

<h3 id="ì¡°ì‘ë²•">ì¡°ì‘ë²•</h3>
<ul>
  <li>ì´ë™ : íŠ¸ë™íŒ¨ë“œ í„°ì¹˜ ì‹œ ë°©í–¥ìœ¼ë¡œ ê¸°ë³¸ ì´ë™, íŠ¸ë™íŒ¨ë“œë¥¼ ëˆ„ë¥´ê³  ë°©í–¥ ì„¤ì • í›„ ë–¼ë©´ í–¥í•˜ëŠ” ìœ„ì¹˜ë¡œ ë¹ ë¥´ê²Œ ì´ë™(í…”ë ˆí¬íŠ¸)</li>
  <li>UI ë° í”Œë ˆì´ì–´, ë“œë¡  ìƒí˜¸ì‘ìš© : íŠ¸ë¦¬ê±°ë¥¼ ëˆ„ë¥´ê³  ì™¼ì†ì„ ì¢Œì—ì„œ ìš°ë¡œ í”ë“¤ë©´ UIì°½ ìƒì„±, ì»¨íŠ¸ë¡¤ëŸ¬ë¡œ í•´ë‹¹ UI í´ë¦­ í›„ íŠ¸ë¦¬ê±° ëˆ„ë¥´ë©´ ê¸°ëŠ¥ ì‹¤í–‰</li>
  <li>ë²½íƒ€ê¸° : ë²½ì— ì»¨íŠ¸ë¡¤ëŸ¬ë¥¼ ëŒ€ê³  íŠ¸ë¦¬ê±°ë¥¼ ëˆ„ë¥¸ ì±„ ì»¨íŠ¸ë¡¤ëŸ¬ë¥¼ ë‹¹ê¹€.</li>
  <li>ì í”„ : ì–‘ ì† ì»¨íŠ¸ë¡¤ëŸ¬ íŠ¸ë¦¬ê±°ë¥¼ ëˆ„ë¥´ê³  ìœ„ ì•„ë˜ë¡œ í˜ê» ë‹¹ê¹€.</li>
  <li>ì¥ì „ : ì´ì•Œì„ ë‹¤ ì˜ë©´ ì¥ì „ í™€ë”ê°€ ì—´ë¦¼. ì´ì•Œì„ ë“¤ì–´ í•´ë‹¹ ìœ„ì¹˜ì— ê°€ì ¸ê°€ë©´ í™€ë”ì— ì´ì•Œì´ ë“¤ì–´ê°. ê·¸ë¦¬ê³  í™€ë”ê°€ ì—´ë¦° ë°©í–¥ìœ¼ë¡œ ì´ì„ ëŒë¦¬ë©´ í™€ë”ê°€ ë‹«íˆê³  ì¥ì „ ì™„ë£Œ.</li>
</ul>

<h3 id="ê²Œì„-êµ¬ì„±">ê²Œì„ êµ¬ì„±</h3>
<h5 id="ì‹±ê¸€-ëª¨ë“œ">ì‹±ê¸€ ëª¨ë“œ</h5>
<ul>
  <li>ê±´ë¬¼ì— ì¡ì„, ì ë“¤ì„ ì£½ì´ê±°ë‚˜ ì¡ì„í•´ì„œ í•´ë‹¹ ìœ„ì¹˜ì— í­íƒ„ì„ ì„¤ì¹˜í•˜ë©´ ì™„ë£Œ</li>
</ul>

<h5 id="ë©€í‹°-ëª¨ë“œ">ë©€í‹° ëª¨ë“œ</h5>
<ul>
  <li>í˜‘ë™ì´ë‚˜ PVPë¥¼ ì¶”ê°€í•˜ë ¤ í–ˆìœ¼ë‚˜ ì‹œê°„ìƒ ë¬¸ì œë¡œ ë¬´ì‚°</li>
</ul>

<h3 id="ë°œí‘œ-ë¬¸ì„œ">ë°œí‘œ ë¬¸ì„œ</h3>
<ul>
  <li>ì°¸ê³  ë§í¬ : https://drive.google.com/file/d/1GspJt_RMxemqi3acA1pPHIJnRSlfREdh/view?usp=sharing</li>
</ul>

<h3 id="í•µì‹¬-ë¡œì§">í•µì‹¬ ë¡œì§</h3>
<ul>
  <li>ì œê°€ ê°œë°œí•œ ë¡œì§ë§Œ ì •ë¦¬í–ˆìŠµë‹ˆë‹¤.</li>
</ul>

<h4 id="ë²½íƒ€ê¸°-ë¡œì§">ë²½íƒ€ê¸° ë¡œì§</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private void ClimbPull()
   {

       // íƒœê·¸ë¥¼ ì´ìš© ì˜¤ë¥¼ ìˆ˜ ìˆëŠ” ì˜¤ë¸Œì íŠ¸ë¥¼ êµ¬ë³„
       if (attachObject.tag == "CLIMB" || attachObject.tag == "GROUND")
       {
           // canGrip : í•¸ë“œ ì½œë¦¬ì „ì— ë‹¿ìœ¼ë©´ true
           // ClimbAction : í¬ë¦¬ê±° ëˆ„ë¥´ê³  ìˆìœ¼ë©´ true
           if (canGrip &amp;&amp; ClimbAction.GetState(inputSource))
           {
               bodyRb.isKinematic = true;
               bodyRb.useGravity = false;

               // ì»¨íŠ¸ë¡¤ëŸ¬ ë³€ë™ ê°’ì„ ë°”ë”” trasfrom ê°’ì— ë”í•´ì¤Œ, ê²Œì„ìƒì—ì„œëŠ” ì† ìœ„ì¹˜ëŠ” ë³€ë™ì´ ì—†ê³  ë°”ë”” ìœ„ì¹˜ê°’ë§Œ ë³€í•˜ê¸° ë•Œë¬¸ì— ì˜¬ë¼ê°€ëŠ” ê²ƒ ì²˜ëŸ¼ ë³´ì„
               body.transform.position += (handPrevPos - this.transform.localPosition);

           }
           else if (ClimbAction.GetStateUp(inputSource))
           {
               bodyRb.isKinematic = false;
               bodyRb.useGravity = true;

               // íŠ¸ë¦¬ê±°ë¥¼ ë• ì„ ë•Œ ì† ìœ„ì¹˜ ë³€ë™ê°’ì„ velocityë¡œ ì£¼ë©´ í•´ë‹¹ ë°©í–¥ìœ¼ë¡œ ì í”„í•˜ëŠ” ë“¯í•œ íš¨ê³¼ë¥¼ ì¤€ë‹¤.
               bodyRb.velocity += (handPrevPos - this.transform.localPosition) / Time.deltaTime;
           }

           handPrevPos = this.transform.localPosition;
       }
   }
</code></pre></div></div>

<h4 id="í…”ë ˆí¬íŠ¸-í¬ë¬¼ì„ -ë¡œì§">í…”ë ˆí¬íŠ¸ í¬ë¬¼ì„  ë¡œì§</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private void UpdatePath()
    {
        // í•¸ë“œ ìœ„ì¹˜
        Transform startPos = isLeft == true ? lHandPos : rHandPos;

        // ì´ë™í•  ìœ„ì¹˜ê°€ ê°ì§€ ëëŠ”ì§€
        Detected = false;

        // í”Œë ˆì´ì–´ ì´ë™ì„ ìœ„í•œ ì¢Œí‘œì™€ ë¼ì¸ì„ ê·¸ë¦¬ê¸° ìœ„í•œ ì¢Œí‘œ
        vertexList.Clear();
        lineVertexList.Clear();

        //í¬ë¬¼ì„ ì´ ë»£ì–´ë‚˜ê°ˆ ë°©í–¥
        velocity = Quaternion.AngleAxis(-angle, startPos.right) * startPos.forward * strength;

        RaycastHit hit;

        // í”Œë ˆì´ì–´ ì´ë™ì€ ì›”ë“œ ì¢Œí‘œë¡œ
        Vector3 pos = startPos.position;
        // í¬ë¬¼ì„ ì€ í„°ì¹˜íŒ¨ë“œë¥¼ í´ë¦­í•œ ì»¨íŠ¸ë¡¤ëŸ¬ë¥¼ ë”°ë¼ê°€ì•¼ í•˜ê¸° ë•Œë¬¸ì— ë¡œì»¬ë¡œ ì„¤ì •
        Vector3 linePos = startPos.localPosition;

        // ì‹œì‘ ìœ„ì¹˜ ë°°ì—´ì— ì €ì¥
        vertexList.Add(pos);
        lineVertexList.Add(linePos);

        // ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ì„ ì¤„ì´ê¸° ìœ„í•´ ì •í•´ì§„ ë²„í…ìˆ˜ê¹Œì§€ë§Œ ê·¸ë¦¬ë„ë¡
        while (!Detected &amp;&amp; vertexList.Count &lt; maxVertexcount)
        {

            // í¬ë¬¼ì„ ì´ ë»£ì–´ë‚˜ê°ˆ ë‹¤ìŒ ìœ„ì¹˜ë¥¼ ê³„ì‚°
            Vector3 newPos = pos + velocity * vertexDelta
                + 0.5f * Physics.gravity * vertexDelta * vertexDelta;
            Vector3 newLinePos = linePos + velocity * vertexDelta
                + 0.5f * Physics.gravity * vertexDelta * vertexDelta;

            vertexList.Add(newPos);
            lineVertexList.Add(newLinePos);

            // ê°€ì¤‘ì¹˜
            velocity += Physics.gravity * vertexDelta;

            // ì˜¬ë°”ë¥¸ ìœ„ì¹˜(tag)ì— ë‹¿ì•˜ëŠ”ì§€ íŒë‹¨  
            if (Physics.Linecast(pos, newPos, out hit))
            {
                if (hit.transform.gameObject.tag == "GROUND"
                    &amp;&amp; hit.transform.position.y &lt; this.transform.position.y + 1
                    &amp;&amp; hit.transform.position.y &gt; this.transform.position.y - 1)
                {
                    groundDetected = true;
                }
                else groundDetected = false;

                Detected = true;
                groundPos = hit.point;
                lastNormal = hit.normal;
            }

            pos = newPos;
            linePos = newLinePos;
        }

        // ê°ì§€í•˜ë©´ ê·¸ ìœ„ì¹˜ë¡œ ë§ˆì»¤ í™œì„±í™”
        if (Detected)
        {

            positionMarker.SetActive(true);
            positionMarker.transform.position = groundPos + (lastNormal * 0.01f);
            positionMarker.transform.rotation = Quaternion.LookRotation(lastNormal);
            positionMarker.transform.Rotate(90.0f, 0, 0);

            if (groundDetected)
            {
                positionMarker.GetComponent&lt;MeshRenderer&gt;().material = MatEnable;
            }
            else
            {
                groundPos = this.transform.position;
                positionMarker.GetComponent&lt;MeshRenderer&gt;().material = MatInvaild;
            }
        }

        // ìœ„ ì¢Œí‘œì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ë¼ì¸ë Œë”ëŸ¬ ìƒì„±
        arcRenderer.positionCount = lineVertexList.Count;
        arcRenderer.SetPositions(lineVertexList.ToArray());
    }

}
</code></pre></div></div>

<h4 id="ë„íƒ„-ë¡œì§">ë„íƒ„ ë¡œì§</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public void Beam()
   {

       // ë„íƒ„ ì´í™íŠ¸ë¥¼ ì•„ì§ ë§Œë“¤ì§€ ì•Šì€ ê²½ìš° ë§Œë“­ë‹ˆë‹¤. ë¼ì¸ ë Œë”ëŸ¬ë¥¼ ì‚¬ìš©
       if (beamGO == null)
       {
           beamGO = new GameObject(beamTypeName, typeof(LineRenderer));
           beamGO.transform.parent = transform;
       }

       LineRenderer beamLR = beamGO.GetComponent&lt;LineRenderer&gt;();
       beamLR.material = beamMaterial;
       beamLR.material.SetColor("_TintColor", beamColor);
       beamLR.startWidth = startBeamWidth;
       beamLR.endWidth = endBeamWidth;

       ë°˜ì‚¬ íšŸìˆ˜
       int reflections = 0;

       // ë„íƒ„ ë¹”ì´ ë°˜ì‚¬ë˜ëŠ” ëª¨ë“  ì¢Œí‘œ
       reflectionPoints = new List&lt;Vector3&gt;();
       reflectionHitObjects = new List&lt;GameObject&gt;();

       // ì²«ë²ˆì§¸ ì¢Œí‘œ ì €ì¥
       reflectionPoints.Add(raycastStartSpot.position);

       // ë§ˆì§€ë§‰ ë°˜ì‚¬ ì§€ì ì„ ì €ì¥
       Vector3 lastPoint = raycastStartSpot.position;

       // ë¹” ê³„ì‚°ì„ ìœ„í•œ ë³€ìˆ˜ ì„ ì–¸
       Vector3 incomingDirection;
       Vector3 reflectDirection;

       // ë¹”ì´ ê³„ì† ë°˜ì‚¬ë¥¼ í•´ì•¼ë˜ëŠ”ì§€ íŒë‹¨
       bool keepReflecting = true;

       Ray ray = new Ray(lastPoint, raycastStartSpot.forward);
       RaycastHit hit;

       do
       {
           // ë‹¤ìŒ ì¢Œí‘œë¥¼ ì´ˆê¸°í™”, ë ˆì´ìºìŠ¤íŠ¸ íˆíŠ¸ê°€ ë¦¬í„´ë˜ì§€ ì•Šìœ¼ë©´ forward direction * ë²”ìœ„
           Vector3 nextPoint = ray.direction * range;

           if (Physics.Raycast(ray, out hit, range))
           {
               // ë‹¤ìŒ ì¢Œí‘œë¥¼ íˆíŠ¸ ì¢Œí‘œë¡œ ì„¤ì •
               nextPoint = hit.point;

               // ë ˆì´ë¥¼ ì  ë‹¤ìŒ ë°©í–¥ì„ ê³„ì‚°
               incomingDirection = nextPoint - lastPoint;
               reflectDirection = Vector3.Reflect(incomingDirection, hit.normal);
               ray = new Ray(nextPoint, reflectDirection);

               // lastPoint ì—…ë°ì´íŠ¸
               lastPoint = hit.point;

               /*
                Hit Effects ìƒëµ
               /*

               LastHitObject = hit.collider.gameObject;

               // ë°˜ì‚¬ íšŒìˆ˜ ì¦ê°€
               reflections++;
           }
           else
           {
               keepReflecting = false;
           }

           // ë‹¤ìŒ ì¢Œí‘œ ê°’ ë°°ì—´ì— ì €ì¥
           reflectionPoints.Add(nextPoint);
           reflectionHitObjects.Add(hit.transform.gameObject);

       } while (keepReflecting &amp;&amp; reflections &lt; maxReflections &amp;&amp; reflect &amp;&amp; (reflectionMaterial == null || (FindMeshRenderer(hit.collider.gameObject) != null &amp;&amp; FindMeshRenderer(hit.collider.gameObject).sharedMaterial == reflectionMaterial)));

       // ë¼ì¸ ë Œë”ëŸ¬ ë¹”ì˜ ê° ì¢Œí‘œ ìœ„ì¹˜ê°’ ì„¤ì •
       //beamLR.SetVertexCount(reflectionPoints.Count);

       beamLR.positionCount = reflectionPoints.Count;

       /*
       muzzleEffects ìƒëµ
       */
   }

</code></pre></div></div>

<h4 id="ê°€ì†ë„-ê°’-ê³„ì‚°-ë¦¬ë³¼ë²„-ì¥ì „-í™€ë”-íƒˆì°©-ê°€ì†ë„-ê³„ì‚°">ê°€ì†ë„ ê°’ ê³„ì‚° (ë¦¬ë³¼ë²„ ì¥ì „ í™€ë” íƒˆì°© ê°€ì†ë„ ê³„ì‚°)</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   public Vector3 LinearAcceleration(out Vector3 vector, Vector3 position, int samples){
		Vector3 averageSpeedChange = Vector3.zero;
		Vector3 averageVelocity = Vector3.zero;
		vector = Vector3.zero;
		Vector3 deltaDistance;
		float deltaTime;
		Vector3 speedA = Vector3.zero;
		Vector3 speedB = Vector3.zero;

        // ìƒ˜í”Œ ì–‘ì„ ê³ ì •, ê°€ì†ë„ ê³„ì‚°ì„ í•˜ë ¤ë©´ ì ì–´ë„ ë‘ê°€ì§€ ë³€í™”ê°€ í•„ìš”
        // ì†ë„ê°€ ë¹ ë¥´ë©´ ìµœì†Œ 3ê°€ì§€ ì´ìƒì˜ ìœ„ì¹˜ ìƒ˜í”Œì´ í•„ìš”
		if(samples &lt; 3){

			samples = 3;
		}

		// ì´ˆê¸°í™”
		if(positionRegister == null) {
			positionRegister = new Vector3[samples];
			posTimeRegister = new float[samples];
		}

        // ìœ„ì¹˜ ë° ì‹œê°„ ìƒ˜í”Œ ê°’ì„ ë°°ì—´ì— ì €ì¥
		for(int i = 0; i &lt; positionRegister.Length - 1; i++){

			positionRegister[i] = positionRegister[i+1];
			posTimeRegister[i] = posTimeRegister[i+1];
		}
		positionRegister[positionRegister.Length - 1] = position;
		posTimeRegister[posTimeRegister.Length - 1] = Time.time;

		positionSamplesTaken++;

		// ê°€ì†ë„ëŠ” ì¶©ë¶„í•œ ìƒ˜í”Œì„ ì–»ì—ˆì„ ë•Œë§Œ ê³„ì‚° ê°€ëŠ¥
		if(positionSamplesTaken &gt;= samples){

			//í‰ê·  ì†ë„ ë³€í™”ë¥¼ ê³„ì‚°
			for(int i = 0; i &lt; positionRegister.Length - 2; i++){

				deltaDistance = positionRegister[i+1] - positionRegister[i];
				deltaTime = posTimeRegister[i+1] - posTimeRegister[i];

				//If deltaTime is 0, the output is invalid.
				if(deltaTime == 0){

					return Vector3.zero;
				}

				speedA = deltaDistance / deltaTime;
				deltaDistance = positionRegister[i+2] - positionRegister[i+1];
				deltaTime = posTimeRegister[i+2] - posTimeRegister[i+1];

				if(deltaTime == 0){

					return  Vector3.zero;
				}

				speedB = deltaDistance / deltaTime;

				//ëˆ„ì ëœ ì†ë„ ë³€í™”
				averageSpeedChange += speedB - speedA;
				averageVelocity += speedB;

			}

			//í‰ê·  ì†ë„ ë³€í™”
			averageSpeedChange /= positionRegister.Length - 2;
			averageVelocity /= positionRegister.Length - 2;

            // ì‹œì°¨
			float deltaTimeTotal = posTimeRegister[posTimeRegister.Length - 1] - posTimeRegister[0];			

            // ìƒ˜í”Œ ìˆ˜ì— ë”°ë¥¸ ê°€ì†ë„ ê³„ì‚°
			vector = averageSpeedChange / deltaTimeTotal;

			//Vector3 curVelocity = (speedA + speedB) / 2.0f;

			return averageVelocity;		
		}
		else {
			return Vector3.zero;
		}
	}
</code></pre></div></div>
:ET