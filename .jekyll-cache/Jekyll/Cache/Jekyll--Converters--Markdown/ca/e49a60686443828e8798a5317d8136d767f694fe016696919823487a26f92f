I"<p>이득우의 언리얼 C++ 게임 개발의 정석의 Chapter05 요약입니다.</p>

<h3 id="폰의-구성-요소">폰의 구성 요소</h3>
<ul>
  <li>인간형 폰
    <ul>
      <li>시각적 요소 : 인간형 폰이 되려면 애니메이션 기능이 필요하다. 애니메이션을 재생하도록 리깅 데이터를 추가한 메시를 스켈레탈 메시라고 하며, 이를 관리하는 컴포넌트는 스켈레탈 메시 컴포넌트이다.</li>
      <li>충돌 요소 : 스켈레탈 메시는 애니메이션에 따라 변하므로 충돌을 담당할 충돌 컴포넌트를 별도로 사용하는 것이 적합하다. 인간형의 경우 캡슐 컴포넌트를 사용한다.</li>
      <li>움직임 요소 : 언리얼 엔진은 폰의 움직임을 위해 플레이어의 입력에 따라 반응하는 폰 무브먼트 컴포넌트라 부르는 특별한 컴포넌트를 제공하고 있다. 언리얼 엔진은 FloatingPawnMovement와 CharacterMovement라는 두가지 폰 무브먼트 컴포넌트를 제공한다.</li>
    </ul>
  </li>
  <li>폰 제작
    <ul>
      <li>Capsule : 폰의 움직임을 담당할 충돌 컴포넌트이다. 보통 충돌 영역은 캐릭터 메시가 쏙 들어갈 만큼의 크기로 설정한다. 루트 컴포넌트로 설정</li>
      <li>SkeletalMesh : 캐릭터 에셋을 보여주고 추가로 애니메이션도 담당한다. 모델링 시 사용했던 소프트웨어 좌표계와 언리얼의 3차원 좌표계가 다른 경우가 있기 때문에 맞춰줘야할 때가 있다. 또한 언리얼 엔진에서의 액터의 기준 위치는 정중앙 위치인 반면에 캐릭터 에셋은 주로 발바닥 기준 위치를 잡기 때문에 Z축으로 절반 높이만큼 내려줘야 한다.</li>
      <li>FloatingPawnMovement : 플레이어의 입력에 따라 캐릭터가 움직이도록 설정해주는 컴포넌트이다. 중력을 고려하지 않은 간단한 움직임을 구현할 수 있다.</li>
      <li>SpringArm : 스프링암은 삼인칭 시점으로 카메라 구도를 편리하게 설정할 수 있는 부가 컴포넌트이다.</li>
      <li>Camera : 폰에 카메라 컴포넌트를 부착하면 언리얼 엔진은 카메라가 바라보는 게임 세계의 화면을 플레이어 화면으로 전송한다. 삼인칭 시점을 구현할 때 카메라 컴포넌트를 스프링암 컴포넌트의 자식으로 설정하고 트랜스폼 정보를 초기화 하면 카메라는 자동으로 스프링암의 끝에 걸린다.</li>
    </ul>
  </li>
</ul>

<h3 id="폰의-조작">폰의 조작</h3>
<ul>
  <li>프로젝트 세팅의 입력 세팅의 Action Mappings와 Axis Mappings라는 두가지 입력 설정이 있다.
    <ul>
      <li>축 매핑(Axis Mapping) : 조이스틱 레버를 의미, 레버가 중립위치에 있으면 0의 값을, 끝 위치에 있으면 설정된 스케일 값에 따라 1혹은 -1의 값을 게임 로직에 전달한다. 기본 세팅 값에서는 A키를 누르면 -1값이, D키를 누르면 1값이 발생하고, 아무것도 누르지 않으면 0값이 지속적으로 발생한다.</li>
      <li>액션 매핑(Action Mapping) : 조이스틱의 버튼을 의미, 버튼이 눌렸을 때와 뗄 때만 신호를 전달한다.</li>
    </ul>
  </li>
  <li>언리얼 엔진은 입력 설정을 처리하기 위해 InputComponent라는 언리얼 오브젝트를 제공한다. InputComponent라는를 사용해 폰의 멤버함수와 입력 설정을 바인딩 시키면, 입력 신호는 자동으로 폰의 멤버 함수 인자로 전달된다. 이를 연결하는 것이 SetupInputComponent 함수이다.</li>
  <li>AddMovementInput 함수를 이용, 폰의 움직임으로 활용한다.</li>
</ul>

<h3 id="유용한-팁">유용한 팁</h3>
<ul>
  <li>플레이 버튼을 눌러 콘텐츠를 테스트 할 때는 매번 언리얼 뷰포트를 클릭해 포커스를 잡아야 입력 신호가 비로소 게임에 전달되는 불편함이 있다. 플레이어 컨트롤러에게 UI를 배제하고 게임에게만 입력을 전달하도록 명령을 내리면 앞으로 편리하게 게임을 테스트 할 수 있다.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  //헤더부분
  protected:
      virtual void BeginPlay() override;

  //소스부분

  void AABPlayerController::BeginPlay()
  {
      Super::BeginPlay();

      FInputModeGameOnly InputMode;
      SetInputMode(InputMode);
  }
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="애니메이션-설정">애니메이션 설정</h3>
<ul>
  <li>게임 중 에셋 로드 : LoadObject<타입></타입></li>
  <li>코드로 애니메이션을 지정하는 방법이 있지만, 게임의 규모가 커지면 이런 방법으로는 관리적인 한계에 부딪힌다. 따라서 언리얼 엔진에서는 애니메이션 블루프린트라는 기능을 제공한다.</li>
  <li>애니메이션 블루프린트는 애님 그래프 로직에 따라 동작하는 캐릭터 애니메이션 시스템을 구동시키는데, 이러한 애니메이션 시스템은 C++ 프로그래밍의 애님 인스턴스라는 클래스로 관리된다.</li>
  <li>스켈레탈 메시 컴포넌트는 자신이 관리하는 캐릭터의 애니메이션을 애님 인스턴스로 위임하는 구조로 설계되어 있다. 따라서 이 애니메이션 블루프린트를 실행시키려면 블루프린트 애셋의 클래스 정보를 애님 인스턴스 속성에 지정해줘야한다.</li>
  <li>스켈레탈 메시 컴포넌트에 애니메이션 블루프린트 클래서 정보 등록 -&gt; 인스턴스 생성 &amp; 애니메이션 관리하도록 동작</li>
</ul>

<h3 id="추가-사항">추가 사항</h3>
<ul>
  <li>애니메이션 블루프린터를 가져오는 과정에서 경로를 못찾는 에러가 발생해서 문제를 찾아 봤다. 구글링에서 찾은 해결법대로 밑에 확장자 부분을 지우니까 잘됐다. 레퍼런스 복사를 해서 그대로 복붙했는데 앞서 스켈레탈 메시는 복붙으로도 잘 돌아가는 반면, 애니메이션 블루프린터는 크래시가 난다. 찾아본 결과 기존 에셋이 아니라 클래스를 불러올때는 확장자 뒤에 _C를 붙여줘 UCLASS로 인식한다고 한다. 주의해야겠다.
```
static ConstructorHelpers::FClassFinder<UAnimInstance> WARRIOR_ANIM(TEXT("/Game/Animations/BP_WarriorAnim.BP_WarriorAnim"));</UAnimInstance></li>
</ul>

<p>-&gt;</p>

<p>static ConstructorHelpers::FClassFinder<UAnimInstance> WARRIOR_ANIM(TEXT("/Game/Animations/BP_WarriorAnim"));
```</UAnimInstance></p>
:ET