I"„<p>í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ ì½”ë”©í…ŒìŠ¤íŠ¸ ì—°ìŠµë¬¸ì œì…ë‹ˆë‹¤. ì—¬ëŸ¬ê°€ì§€ ë°©ë²•ì„ ì‹œë„í•´ë³´ë‹¤ ì‹œê°„ì´ ë„ˆë¬´ ê±¸ë ¤ì„œ íŒíŠ¸ë¥¼ ì–»ê¸° ìœ„í•´ ì§ˆë¬¸ ëª©ë¡ì„ ë´¤ìŠµë‹ˆë‹¤. ì´ ë¬¸ì œì˜ í’€ì´ë²•ìœ¼ë¡œ ë§ì€ ì‚¬ëŒë“¤ì´ DFSë¥¼ ë§ì´ ì‚¬ìš©í•˜ëŠ” ë“¯ í–ˆìŠµë‹ˆë‹¤. êµ¬ê¸€ë§ì„ í†µí•´ DFS(ê¹Šì´ ìš°ì„  íƒìƒ‰)ì™€ ê·¸ì™€ í•¨ê»˜ ë‚˜ì˜¤ëŠ” BFS(ë„“ì´ ìš°ì„  íƒìƒ‰)ì— ëŒ€í•´ ê³µë¶€í–ˆìŠµë‹ˆë‹¤. ì ì ˆí•œ ë°©ë²•ì´ì˜€ê³  ìˆ˜ì›”í•˜ê²Œ ë¬¸ì œë¥¼ í’€ ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ì±„ì  ì‹œìŠ¤í…œì˜ ë¬¸ì œì¸ì§€ ì˜ ëª¨ë¥´ê² ì§€ë§Œ ì „ì—­ë³€ìˆ˜ë¡œ ì„ ì–¸í•œ í•œ ë³€ìˆ˜ê°€ ë¬¸ì œì˜€ìŠµë‹ˆë‹¤. ê·¸ ë³€ìˆ˜ë¥¼ solution í•¨ìˆ˜ ë‚´ì—ì„œ ì„ ì–¸í•˜ê³  ì´ˆê¸°í™” í•´ì£¼ì—ˆë”ë‹ˆ í†µê³¼ëìŠµë‹ˆë‹¤.</p>

<p>DFSë¥¼ ë§Œë“œëŠ” ë°©ë²•ìœ¼ë¡œ í¬ê²Œ ì¬ê·€ì™€ ìŠ¤íƒì„ ì´ìš©í•©ë‹ˆë‹¤. BFSëŠ” íë¥¼ ì´ìš©í•´ ë§Œë“­ë‹ˆë‹¤. ì¬ê·€ì™€ ìŠ¤íƒì„ ì´ìš©í•œ ë²„ì „ê³¼ BFSë¥¼ ì´ìš©í•´ì„œë„ í’€ì–´ë´¤ìŠµë‹ˆë‹¤.</p>

<h4 id="ë¬¸ì œ-ì„¤ëª…">ë¬¸ì œ ì„¤ëª…</h4>
<h3 id="ì¹´ì¹´ì˜¤-í”„ë Œì¦ˆ-ì»¬ëŸ¬ë§ë¶">ì¹´ì¹´ì˜¤ í”„ë Œì¦ˆ ì»¬ëŸ¬ë§ë¶</h3>
<p>ì¶œíŒì‚¬ì˜ í¸ì§‘ìì¸ ì–´í”¼ì¹˜ëŠ” ë„¤ì˜¤ì—ê²Œ ì»¬ëŸ¬ë§ë¶ì— ë“¤ì–´ê°ˆ ì›í™”ë¥¼ ê·¸ë ¤ë‹¬ë¼ê³  ë¶€íƒí•˜ì—¬ ì—¬ëŸ¬ ì¥ì˜ ê·¸ë¦¼ì„ ë°›ì•˜ë‹¤. ì—¬ëŸ¬ ì¥ì˜ ê·¸ë¦¼ì„ ë‚œì´ë„ ìˆœìœ¼ë¡œ ì»¬ëŸ¬ë§ë¶ì— ë„£ê³  ì‹¶ì—ˆë˜ ì–´í”¼ì¹˜ëŠ” ì˜ì—­ì´ ë§ìœ¼ë©´ ìƒ‰ì¹ í•˜ê¸°ê°€ ê¹Œë‹¤ë¡œì›Œ ì–´ë ¤ì›Œì§„ë‹¤ëŠ” ì‚¬ì‹¤ì„ ë°œê²¬í•˜ê³  ê·¸ë¦¼ì˜ ë‚œì´ë„ë¥¼ ì˜ì—­ì˜ ìˆ˜ë¡œ ì •ì˜í•˜ì˜€ë‹¤. (ì˜ì—­ì´ë€ ìƒí•˜ì¢Œìš°ë¡œ ì—°ê²°ëœ ê°™ì€ ìƒ‰ìƒì˜ ê³µê°„ì„ ì˜ë¯¸í•œë‹¤.)</p>

<p>ê·¸ë¦¼ì— ëª‡ ê°œì˜ ì˜ì—­ì´ ìˆëŠ”ì§€ì™€ ê°€ì¥ í° ì˜ì—­ì˜ ë„“ì´ëŠ” ì–¼ë§ˆì¸ì§€ ê³„ì‚°í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•´ë³´ì.</p>

<p>ìœ„ì˜ ê·¸ë¦¼ì€ ì´ 12ê°œ ì˜ì—­ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆìœ¼ë©°, ê°€ì¥ ë„“ì€ ì˜ì—­ì€ ì–´í”¼ì¹˜ì˜ ì–¼êµ´ë©´ìœ¼ë¡œ ë„“ì´ëŠ” 120ì´ë‹¤.</p>

<h4 id="ì…ë ¥-í˜•ì‹">ì…ë ¥ í˜•ì‹</h4>
<p>ì…ë ¥ì€ ê·¸ë¦¼ì˜ í¬ê¸°ë¥¼ ë‚˜íƒ€ë‚´ëŠ” mê³¼ n, ê·¸ë¦¬ê³  ê·¸ë¦¼ì„ ë‚˜íƒ€ë‚´ëŠ” m Ã— n í¬ê¸°ì˜ 2ì°¨ì› ë°°ì—´ pictureë¡œ ì£¼ì–´ì§„ë‹¤. ì œí•œì¡°ê±´ì€ ì•„ë˜ì™€ ê°™ë‹¤.</p>
<ul>
  <li>1 &lt;= m, n &lt;= 100</li>
  <li>pictureì˜ ì›ì†ŒëŠ” 0 ì´ìƒ 2^31 - 1 ì´í•˜ì˜ ì„ì˜ì˜ ê°’ì´ë‹¤.</li>
  <li>pictureì˜ ì›ì†Œ ì¤‘ ê°’ì´ 0ì¸ ê²½ìš°ëŠ” ìƒ‰ì¹ í•˜ì§€ ì•ŠëŠ” ì˜ì—­ì„ ëœ»í•œë‹¤.</li>
</ul>

<h4 id="ì¶œë ¥-í˜•ì‹">ì¶œë ¥ í˜•ì‹</h4>
<ul>
  <li>ë¦¬í„´ íƒ€ì…ì€ ì›ì†Œê°€ ë‘ ê°œì¸ ì •ìˆ˜ ë°°ì—´ì´ë‹¤. ê·¸ë¦¼ì— ëª‡ ê°œì˜ ì˜ì—­ì´ ìˆëŠ”ì§€ì™€ ê°€ì¥ í° ì˜ì—­ì€ ëª‡ ì¹¸ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆëŠ”ì§€ë¥¼ ë¦¬í„´í•œë‹¤.</li>
</ul>

<h3 id="í’€ì´">í’€ì´</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;

using namespace std;

int sizeCnt;
int maxX;
int maxY;
vector&lt;int&gt; dirX;
vector&lt;int&gt; dirY;

// ì¬ê·€ì„ ì´ìš©í•œ DFS
void dfs(int y, int x, vector&lt;vector&lt;int&gt;&gt; picture, vector&lt;vector&lt;bool&gt;&gt;&amp; visited){

    int nx, ny;

    sizeCnt++;
    visited[y][x] = true;

    for(int i = 0; i &lt; 4; i++){

        nx = x + dirX[i];
        ny = y + dirY[i];

        if(nx &gt;= 0 &amp;&amp; nx &lt; maxX &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; maxY){

           if(picture[ny][nx] == picture[y][x] &amp;&amp; visited[ny][nx] != true)
               dfs(ny, nx, picture, visited);

        }
    }
}

//ìŠ¤íƒì„ ì´ìš©í•œ DFS
void StackDFS(int y, int x, vector&lt;vector&lt;int&gt;&gt; picture, vector&lt;vector&lt;bool&gt;&gt;&amp; visited){

    stack&lt;pair&lt;int, int&gt;&gt; s;
    s.push(make_pair(y, x));

    sizeCnt++;
    visited[y][x] = true;

    while(!s.empty()){
        int tempY = s.top().first;
        int tempX = s.top().second;
        s.pop();

        for(int i = 0; i &lt; 4; i++){

            int ny = tempY + dirY[i];
            int nx = tempX + dirX[i];

            if(nx &gt;= 0 &amp;&amp; nx &lt; maxX &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; maxY){

                if(picture[ny][nx] == picture[tempY][tempX] &amp;&amp; visited[ny][nx] != true){

                    sizeCnt++;
                    visited[ny][nx] = true;
                    //s.push(make_pair(tempY, tempX));
                    s.push(make_pair(ny, nx));
                }
            }
        }
    }
}

//BFS
void BFS(int y, int x, vector&lt;vector&lt;int&gt;&gt; picture, vector&lt;vector&lt;bool&gt;&gt;&amp; visited){
    queue&lt;pair&lt;int, int&gt;&gt; q;
    q.push(make_pair(y, x));

    visited[y][x] = true;
    sizeCnt++;

    while(!q.empty()){
        int tempY = q.front().first;
        int tempX = q.front().second;
        q.pop();

        for(int i = 0; i &lt; 4; i++){
            int ny = tempY + dirY[i];
            int nx = tempX + dirX[i];

            if(nx &gt;= 0 &amp;&amp; nx &lt; maxX &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; maxY){

                if(picture[ny][nx] == picture[tempY][tempX] &amp;&amp; visited[ny][nx] != true){

                    sizeCnt++;
                    visited[ny][nx] = true;                
                    q.push(make_pair(ny, nx));
                }
            }
        }

    }
}

// ì „ì—­ ë³€ìˆ˜ë¥¼ ì •ì˜í•  ê²½ìš° í•¨ìˆ˜ ë‚´ì— ì´ˆê¸°í™” ì½”ë“œë¥¼ ê¼­ ì‘ì„±í•´ì£¼ì„¸ìš”.
vector&lt;int&gt; solution(int m, int n, vector&lt;vector&lt;int&gt;&gt; picture) {
    int number_of_area = 0;
    int max_size_of_one_area = 0;

    maxX = n;
    maxY = m;
    dirX = { -1, 0, 1, 0 };
    dirY = { 0, -1, 0, 1 };

    vector&lt;vector&lt;bool&gt;&gt; visited(m, vector&lt;bool&gt;(n, false));

    for(int i = 0; i &lt; m; i++){
        for(int j = 0; j &lt; n; j++){

            if(picture[i][j] != 0 &amp;&amp; visited[i][j] != true){

                sizeCnt = 0;
                dfs(i, j, picture, visited);

                number_of_area++;
                if(max_size_of_one_area &lt; sizeCnt) max_size_of_one_area = sizeCnt;
            }
        }
    }    

    vector&lt;int&gt; answer(2);
    answer[0] = number_of_area;
    answer[1] = max_size_of_one_area;
    return answer;
}
</code></pre></div></div>
:ET