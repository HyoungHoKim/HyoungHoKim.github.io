---
layout: post
title:  "게임 프로그래밍 패턴 Chapter_01"
date:   2020-12-12 00:57:13 +0900
categories: [STUDY, STUDY/GPP]
---

### 시작하며
- 졸업을 하고 국비지원 학원을 다니게 되면서 작은 게임들을 몇 개 만들었습니다. 제가 할 수 있는 능력 내에 열심히 만들었지만 내가 짠 코드가 좋은 코드인지 판단할 수가 없었습니다. 그래서 고민 중에 구글링을 통해 이 책에 대해 접하게 됐고, 그날 바로 구매하게 됐습니다. 바로 4개월 저전에!! 그 기간동안 놀진 않았지만 막상 책에 손이 가지가 않았습니다... 더는 안되겠다 싶어서 하루에 한 챕터씩이라도 읽어보자는 생각으로 글 남깁니다. 가즈아!!

### Chapter 1

#### 1.1. 소프트웨어 구조란?
- 좋은 구조란 뭔가를 고쳐야할 때 그럴 줄 알았다는 듯이 코드가 준비되어 있는 걸 의미한다. 즉, 코드를 건들이지 않고도 적당한 함수 몇 개만 호출하면 원하는 작업을 할 수 있어야 한다. 하지만 이는 현실적으로 쉽지 않다. 하나씩 나눠서 생각해보자
  - 먼저 구조 변경과 관련이 있다.
  - 누군가는 코드를 고쳐야 한다.
  - 얼마나 쉽게 변경할 수 있느냐가 코드 설계를 평가하는 척도가 된다.
  - 변화가 없는 코드는 출발선을 결코 떠나지 않는 달리기 선수와 다를바가 없다.
- 코드를 고치는 방법
  - 먼저 기존 코드를 이해해야 한다. 전체 프로그램을 다 이해해야 하는 건 아니지만, 고치려는 코드와 관련된 부분은 머릿속에 집어넣어야 한다. 사실 프로그래밍에서 가장 오래 걸리는 부분이다.
  - 머릿 속에 코드에 대한 큰 그림을 그리면 해결책을 금방 찾을 수 있다.
  - 업무 할당 -> 코드 파악 -> 문제 해결 코드 작성 -> 코드 정리-> 반복
- 디커플링은 어떻게 도움이 되는가?
  - 다양하게 정의할 수 있지만, 저자는 양쪽 코드 중에서 한쪽이 없으면 코드를 이해할 수 없을 때 둘이 커플링이 되어있다고 본다. 두 코드를 디커플링하면, 각각을 따로 이해할 수 있게 된다. 작업과 관련된 코드가 하나에만 연관되어 있다면, **한 쪽** 코드만 머리에 집어넣으면 된다.
  - **작업이 들어가기 전에 알아야할 지식의 양을 줄이는 것**
  - 디커플링의 다른 정의는 '어느 한 코드를 변경했을 때 다른 코드를 변경하지 않아도 된다'이다. 작업을 위해서는 코드 **어딘가**를 고쳐야 하지만, 커플링이 적은 코드일수록 변경이 나머지 게임 코드에 미치는 영향이 적다.

#### 1.2. 비용은?
- 추상화, 모듈화, 디자인 패턴, 소프트웨어 구조등 구조화를 통해 생산성을 높히는 것도 좋지만, 이런 구조화에 너무 집중하다보면 게임 출시 같은 본질을 놓칠 수가 있다.
- 확장성이라는 세이렌의 노래가 얼마나 많은 개발자들을 엔진은 게임을 만들기 위해 있다는 것을 잊고 '엔진' 그 자체에 시간을 낭비하게 만들었던가.

#### 1.3. 성능과 비용
- 소프트웨어 구조와 추상화가 게임 성능을 저하시킨다는 비판도 있다. 코드를 유연하게 만드는 많은 패턴이 가상함수, 인터페이스, 포인터, 메시지 같은 메커니즘에 의존하는데, 다들 어느정도 런타임 비용을 요구한다.
- 많은 소프트웨어 구조는 코드를 더 유연하고 쉽게 변경할 수 있게 만들기 위해 존재한다. 프로그램의 가정을 줄인다는 뜻이다.
- 성능은 전부 가정에 기반한다.
- 유연성이 좋아야 게임을 쉽게 변경할 수 있다. 개발 속도는 게임 재미를 찾는데 꼭 필요하다. 아이디어를 빠르게 시험해보고 느낌을 빨리 확인하면 할수록, 더 많이 시도해볼 수 있고 멋진걸 찾을 가능성이 높아진다.
- 프로토타이핑을 빠르게 하기 위해서 프로그램을 유연하게 만들면 성능상 비용이 발생한다. 반대로 코드를 최적화하면 유연성이 떨어진다.

#### 1.4. 나쁜 코드의 장점
- 저자는 '제대로' 만드는 것을 선호하지만, 엉성한 코드도 나름의 가치는 있다.
- 구조화가 잘된 코드를 만들려면 많이 고민해야한다. 즉, 시간과 노력이 필요하다.
- 기획 확인에 필요한 기능만 간신히 돌아가도록 대상 코드를 작성하는 프로토타이핑 기법은 아주 적법한 프로그래밍 실천법이다. 다만 주의사항이 있다. 버릴 코드는, 나중에 확실히 버릴 수 있게 해야한다.

#### 1.5. 균형 잡기
- 우리에겐 다음과 같은 목표가 있다.
  1. 프로젝트 개발 기간 동안 코드를 쉽게 이해할 수 있도록 구조를 깔끔하게 만들고 싶다.
  2. 실행 성능을 최적화하고 싶다.
  3. 지금 개발 중인 기능을 최대한 빠르게 구현하고 싶다.
- 이들 목표는 서로 어는 정도 상반된다. 셋 다 장단점이 있기 때문에 트레이드오프 외에는 명쾌한 정답이 없다.

#### 1.6. 단순함
- 이런 제약을 완화할 방법이 혹시라도 하나 있다면 **단순함**이 아닐까 싶다.
- 자료구조와 알고리즘을 (순서대로) 먼저 잡아놓고 여기서부터 다른 방법을 찾아간다. 코드를 단순하게 유지하면 전체 코드를 줄일 수 있다. 이러면 코드를 고칠 때 먼저 머리에 담아야할 코드의 양이 줄어든다. 과부하가 적고 실행할 코드도 적다보니 실행 속도가 빠른 경우가 많다.
- 코드가 단순하다고 짜는데 걸리는 시간이 적은 건 아니다. 하지만 좋은 해결책은 코드를 덧붙이는게 아니라 필요없는 코드를 **빼는** 것이다.

#### 1.7. 마치며
- 추상화와 디커플링을 잘 활용하면 코드를 점차 쉽고 빠르게 만들 수 있다. 하지만, 지금 고민 중인 코드에 유연함이 필요하다는 확신이 없다면 추상화와 디커플링을 적용하느라고 시간을 낭비하지 말자.
- 개발 내내 성능을 고민하고, 최적화에 맞게 설계해야한다. 하지만 가정을 코드에 박아 넣어야 하는 저수준의 핵심 최적화는 가능하다면 늦게하라.
- 게임 기획 내용을 확인해볼 수 있도록 빠르게 개발하되, 너무 서두르느라 코드를 엉망으로 만들지 말자. 결국 그 코드로 작업을 해야하는건 우리다.
- 나중애 버릴 코드를 잘 만들겠다고 시간 낭비하지 말자. 록 스타들이 호텔 방을 어지르는 이유는 다음 날 계산하고 나가면 그만이라는 것을 알기 때문이다.
- 무엇보다, **뭔가 재미있는 걸 만들고 싶다면 먼저 만드는데에서 재미를 느껴보라**.
